import pandas as pd
import re

class TravelPlanner:
    def __init__(self, data_source):
        # Store the path to the CSV file and load the flight data into a DataFrame
        self.data_source = data_source
        self.flights_df = self.load_data()

    def load_data(self):
        # Attempt to load and clean the flight data
        try:
            df = pd.read_csv(self.data_source, dtype=str, low_memory=False)
            df["fare_low"] = pd.to_numeric(df["fare_low"], errors="coerce")  # Ensure fare column is numeric
            print("DEBUG: Flight data loaded successfully.")
            return df
        except Exception as e:
            print(f"DEBUG: Error loading flight data: {e}")
            return None

    def match_city(self, user_city, df_column):
        # Returns a boolean Series where city names approximately match the user's input
        if pd.isna(user_city) or user_city.strip() == "":
            return pd.Series(False, index=df_column.index)
        safe_city = re.escape(user_city.strip().lower())  # Escape special regex characters
        return df_column.str.lower().str.contains(safe_city, na=False)  # Match city safely

    def get_travel_cost(self, source, destination):
        # Compute travel cost between two cities, including direct and one-stop flights
        if self.flights_df is None:
            print("DEBUG: No flight data available.")
            return None, None, None

        source_clean = source.strip().lower()
        destination_clean = destination.strip().lower()
        df = self.flights_df

        # Try to find a direct flight
        direct = df[self.match_city(source_clean, df["city1"]) & self.match_city(destination_clean, df["city2"])]
        if not direct.empty:
            print("DEBUG: Direct flight found.")
            return direct["fare_low"].min(), None, None

        # If no direct flight, look for a one-stop route
        print("DEBUG: No direct flight found, searching for a one-stop connection...")
        stops = df["city1"].dropna().unique()  # Get list of all departure cities

        for stop in stops:
            stop = str(stop).strip().lower()
            if stop in {source_clean, destination_clean}:
                continue
            # Find flights from source → stop and stop → destination
            to_stop = df[self.match_city(source_clean, df["city1"]) & self.match_city(stop, df["city2"])]
            from_stop = df[self.match_city(stop, df["city1"]) & self.match_city(destination_clean, df["city2"])]
            if not to_stop.empty and not from_stop.empty:
                total_fare = to_stop["fare_low"].min() + from_stop["fare_low"].min()
                print(f"DEBUG: One-stop flight found via {stop}")
                return total_fare, stop, True

        # If no routes found at all
        print("DEBUG: No one-stop connection found.")
        return None, None, False

    def calculate_expense(self, source, destination, num_nights, return_flight):
        # Calculates total estimated travel cost including hotel stays and optional return flight
        outbound_cost, outbound_conn, outbound_has_conn = self.get_travel_cost(source, destination)
        if outbound_cost is None:
            print(f"DEBUG: No flights found from {source} to {destination}.")
            return

        # Check if return flight is needed and available
        if return_flight:
            return_cost, return_conn, return_has_conn = self.get_travel_cost(destination, source)
            if return_cost is None:
                print(f"DEBUG: No return flight found from {destination} to {source}. Proceeding one-way.")
                return_flight = False
                total_cost = outbound_cost
            else:
                total_cost = outbound_cost + return_cost
        else:
            total_cost = outbound_cost

        # Calculate hotel and total trip costs
        hotel_cost = num_nights * 100
        trip_cost = total_cost + hotel_cost

        # Output cost breakdown
        print("\nEstimated Travel Expenses:")
        if outbound_has_conn:
            print(f"Outbound Flight: {source} → {outbound_conn} → {destination} (1+ Stops)")
        else:
            print(f"Outbound Flight: {source} → {destination} (Direct)")

        if return_flight:
            if return_has_conn:
                print(f"Return Flight: {destination} → {return_conn} → {source} (1+ Stops)")
            else:
                print(f"Return Flight: {destination} → {source} (Direct)")
            print(f"Total Flight Cost (Round-Trip): ${total_cost:.2f}")
        else:
            print(f"Total Flight Cost (One-Way): ${total_cost:.2f}")

        print(f"Hotel Cost ($100/night x {num_nights} nights): ${hotel_cost:.2f}")
        print(f"Total Estimated Cost: ${trip_cost:.2f}")

# === CLI Interface ===
if __name__ == "__main__":
    file_path = "C:/Users/marc/Downloads/Updated_Flight_Data_Short.csv"
    planner = TravelPlanner(file_path)

    # Gather user input
    source = input("Enter your source city: ").strip()
    destination = input("Enter your destination city: ").strip()
    nights = int(input("Enter number of nights at destination: ").strip())
    return_trip = input("Do you need a return flight? (yes/no): ").strip().lower() in ["yes", "y"]

    # Run cost calculation
    planner.calculate_expense(source, destination, nights, return_trip)
